<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="John Doe" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      C# 调用非托管 DLL 参数传递总结 
      
      
      |
    
     ashe&#39;s blog
  </title>

  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  
<link rel="stylesheet" href="/css/github-markdown-light.css">


  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 8.1.1"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">ashe</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">C# 调用非托管 DLL 参数传递总结</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2025-07-01 20:55:10
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="标签"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/c-sharp/" title="C#">
                    #C#
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="数字类型"><a class="header-anchor" href="#数字类型">#</a>数字类型</h2>
<p>基本类型没有什么特别的地方，直接传递即可：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo1(char v1, short v2, int v3, float v4, double v5)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo1</span>(<span class="params"><span class="built_in">char</span> v1, <span class="built_in">short</span> v2, <span class="built_in">int</span> v3, <span class="built_in">float</span> v4, <span class="built_in">double</span> v5</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>对于指针或引用类型需要加入<code>ref</code>关键字：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo2(int* v1, int&amp; v2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo2</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> v1, <span class="keyword">ref</span> <span class="built_in">int</span> v2</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>引用类型是 C++ 特有的，从规范上讲不建议在接口中使用引用类型，而应该用指针。</p>
<h3 id="数字类型对照表"><a class="header-anchor" href="#数字类型对照表">#</a>数字类型对照表</h3>
<p>下面是一些常见 C 数字类型及其在 C# 中的对应类型的对照表：</p>
<table>
<thead>
<tr>
<th>C 数据类型</th>
<th>C# 数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>char</td>
</tr>
<tr>
<td>unsigned char</td>
<td>byte</td>
</tr>
<tr>
<td>signed char</td>
<td>sbyte</td>
</tr>
<tr>
<td>short</td>
<td>short</td>
</tr>
<tr>
<td>unsigned short</td>
<td>ushort</td>
</tr>
<tr>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>unsigned int</td>
<td>uint</td>
</tr>
<tr>
<td>long</td>
<td>long</td>
</tr>
<tr>
<td>unsigned long</td>
<td>ulong</td>
</tr>
<tr>
<td>long long</td>
<td>long (or) System.Int64</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>ulong (or) System.UInt64</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>double</td>
<td>double</td>
</tr>
<tr>
<td>long double</td>
<td>decimal</td>
</tr>
<tr>
<td>size_t</td>
<td>UIntPtr</td>
</tr>
</tbody>
</table>
<h2 id="布尔类型"><a class="header-anchor" href="#布尔类型">#</a>布尔类型</h2>
<p>在 DLL 接口中，一般能见到<code>bool</code>和<code>BOOL</code>两种类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Foo1</span><span class="params">()</span>; <span class="comment">// 不推荐</span></span><br><span class="line">BOOL <span class="title function_">Foo2</span><span class="params">()</span>; <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure>
<p><code>bool</code>和<code>BOOL</code>是 C++ 和 Windows API 中使用的两种不同的布尔类型，它们之间存在一些区别。</p>
<ol>
<li>
<p><strong><code>bool</code>类型 (C++ 中)</strong>:</p>
<ul>
<li><code>bool</code>是 C++ 标准库中引入的布尔类型。</li>
<li><code>bool</code>类型的大小在标准规范中没有特别指定，但通常情况下，它占用一个字节（8位）。</li>
<li><code>bool</code>类型的值可以是 <code>true</code> 或 <code>false</code>。</li>
</ul>
</li>
<li>
<p><strong><code>BOOL</code>类型 (Windows API 中)</strong>:</p>
<ul>
<li><code>BOOL</code>是 Windows API 中广泛使用的布尔类型。</li>
<li><code>BOOL</code>类型在 Windows API 中通常被定义为一个 4 字节整数（32位），其中<code>FALSE</code>被定义为<code>0</code>，其他任何值被定义为<code>TRUE</code>。</li>
<li><code>BOOL</code>类型的使用是为了与 Windows 操作系统和其 API 的兼容性。</li>
</ul>
</li>
</ol>
<p><br>
C# 中的<code>bool</code>类型可以很好地与 C++ 的<code>bool</code>类型兼容，因为它们都表示布尔值，即<code>true</code>或<code>false</code>。<br>
如果要与使用<code>BOOL</code>的 C++ 代码进行交互，需要进行一些额外的处理。<br>
例如，对于一个返回<code>BOOL</code>的 Windows API 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyFunction</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以在 C# 中这样声明：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;YourLibrary.dll&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">return: MarshalAs(UnmanagedType.Bool)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">MyFunction</span>()</span>;</span><br></pre></td></tr></table></figure>
<p>使用<code>MarshalAs</code>特性来确保<code>BOOL</code>被正确映射到<code>bool</code>。<br>
<br>
其实不使用 <code>[return: MarshalAs(UnmanagedType.Bool)]</code> 特性也可能得到正确的结果，因为 .NET 框架通常会自动处理返回值的映射。然而，使用<code>MarshalAs</code>是一个良好的做法，因为它提供了更清晰的代码和更可靠的结果。<br>
<br>
关于布尔类型的一些知识：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/28514373">What is the size of a boolean In C#? Does it really take 4-bytes?</a></p>
<h2 id="数组"><a class="header-anchor" href="#数组">#</a>数组</h2>
<p>数组本质上就是指针。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo5(int* arr1, int arr2[])</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo5</span>(<span class="params"><span class="built_in">int</span>[] arr1, <span class="built_in">int</span>[] arr2</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>注意：函数内对数组的修改会影响原数组</strong>，因为数组是引用类型。</p>
<h2 id="字符串"><a class="header-anchor" href="#字符串">#</a>字符串</h2>
<p>默认是窄字符，使用本机编码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo3(const char* str)</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo3</span>(<span class="params"><span class="built_in">string</span> v1</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如果是宽字符，则需要通过 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.charset">CharSet</a> 参数指定为<code>Unicode</code>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo4(const wchar_t* str)</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME, CharSet = CharSet.Unicode)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo4</span>(<span class="params"><span class="built_in">string</span> v1</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如果同时出现窄字符和宽字符（不好的设计）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo7(const char* str1, const wchar_t* str2)</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME, CharSet = CharSet.Unicode)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo7</span>(<span class="params">[MarshalAs(UnmanagedType.LPStr</span>)]<span class="built_in">string</span> v1, [<span class="title">MarshalAs</span>(<span class="params">UnmanagedType.LPWStr</span>)]<span class="built_in">string</span> v2)</span>;</span><br></pre></td></tr></table></figure>
<p>通过 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshalasattribute">MarshalAsAttribute</a> 指示封送类型。而<code>CharSet</code>将不再生效。</p>
<h3 id="传出字符串"><a class="header-anchor" href="#传出字符串">#</a>传出字符串</h3>
<p>使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.text.stringbuilder">StringBuilder</a> 类型接受字符串。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void __stdcall Foo6(char* buf, const int bufLen)</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo6</span>(<span class="params">StringBuilder str, <span class="built_in">int</span> len</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder(<span class="number">10</span>);</span><br><span class="line">MyLib.Foo6(sb, sb.Capacity);</span><br></pre></td></tr></table></figure>
<h3 id="返回字符串"><a class="header-anchor" href="#返回字符串">#</a>返回字符串</h3>
<p>某些情况下可能会直接返回一个<code>char*</code>作为字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* __stdcall <span class="title">Foo8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* myString = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* dynamicString = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(myString) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(dynamicString, myString);</span><br><span class="line">    <span class="keyword">return</span> dynamicString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么此时就不能用<code>string</code>接受了，而需要使用<code>IntPtr</code>作为返回类型，再用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.ptrtostringansi">Marshal.PtrToStringAnsi</a> 转为字符串：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">Foo8</span>()</span>;</span><br><span class="line"></span><br><span class="line">IntPtr p = MyLib.Foo8();</span><br><span class="line"><span class="built_in">string</span> s = Marshal.PtrToStringAnsi(p);</span><br></pre></td></tr></table></figure>
<p>宽字符版：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.ptrtostringuni">Marshal.PtrToStringUni</a><br>
UTF-8版：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.ptrtostringutf8">Marshal.PtrToStringUTF8</a><br>
另外还要注意，当 DLL 在堆上分配了内存后，还应该提供释放内存的接口方法，否则会产生内存泄露。</p>
<h2 id="结构类型"><a class="header-anchor" href="#结构类型">#</a>结构类型</h2>
<p>结构是值类型，所以和基础类型的用法一样：<br>
下面是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)  <span class="comment">// 内存按1字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __stdcall <span class="title function_">Foo9</span><span class="params">(MyStruct s)</span></span><br><span class="line">&#123;</span><br><span class="line">    s.x = <span class="number">5</span>;</span><br><span class="line">    s.y = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，结构需要通过 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.structlayoutattribute">StructLayout</a> 指定内存布局。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential)</span>]  <span class="comment">// 顺序布局，也就是按1字节对齐</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo9</span>(<span class="params">MyStruct ms</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ms = <span class="keyword">new</span> MyStruct();</span><br><span class="line">ms.x = <span class="number">1</span>;</span><br><span class="line">ms.y = <span class="number">2</span>;</span><br><span class="line">MyLib.Foo9(ms);</span><br><span class="line">MessageBox.Show(<span class="string">$&quot;<span class="subst">&#123;ms.x&#125;</span>, <span class="subst">&#123;ms.y&#125;</span>&quot;</span>); <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure>
<p>如果需要在函数内对结构进行修改，那么需要使用<code>ref</code>来定义参数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Foo9</span>(<span class="params"><span class="keyword">ref</span> MyStruct ms</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="返回结构"><a class="header-anchor" href="#返回结构">#</a>返回结构</h3>
<p>与字符串不同，结构体可以直接返回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyStruct __stdcall <span class="title function_">Foo10</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyStruct ms;</span><br><span class="line">    ms.x = <span class="number">5</span>;</span><br><span class="line">    ms.y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> MyStruct <span class="title">Foo10</span>()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="返回结构指针"><a class="header-anchor" href="#返回结构指针">#</a>返回结构指针</h3>
<p>可以用<code>ref</code>关键字定义结构体指针：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyStruct* __stdcall Foo11()</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(DLL_NAME)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">ref</span> MyStruct <span class="title">Foo11</span>()</span>;</span><br></pre></td></tr></table></figure>
<p>但是这样无法得到结构的指针，也就不能释放它了，导致内存泄露。<br>
所以建议使用<code>IntPtr</code>作为返回类型，然后用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.ptrtostructure">Marshal.PtrToStructure</a> 转换：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntPtr p = MyLib.Foo11();</span><br><span class="line"><span class="keyword">var</span> ms = Marshal.PtrToStructure&lt;MyStruct&gt;(p);</span><br><span class="line">MessageBox.Show(<span class="string">$&quot;<span class="subst">&#123;ms.x&#125;</span>, <span class="subst">&#123;ms.y&#125;</span>&quot;</span>);</span><br><span class="line">MyLib.Free(p);  <span class="comment">// DLL提供释放接口</span></span><br></pre></td></tr></table></figure>
<h2 id="回调函数"><a class="header-anchor" href="#回调函数">#</a>回调函数</h2>
<p>需要使用委托来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们要定义一个回调函数原型，它接受一个整数参数并返回一个整数。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*CallbackFunction)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> __stdcall <span class="title">SomeFunction</span><span class="params">(CallbackFunction callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callback</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C#中使用DLL中的回调函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 委托的签名与回调函数相匹配</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">CallbackDelegate</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;YourDLL.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">SomeFunction</span>(<span class="params">[MarshalAs(UnmanagedType.FunctionPtr</span>)] CallbackDelegate callback)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建委托实例，并将其传递给DLL中的函数</span></span><br><span class="line">CallbackDelegate myCallback = (<span class="keyword">value</span>) =&gt; &#123;</span><br><span class="line">   Console.WriteLine(<span class="string">$&quot;Callback called with value: <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">value</span> * <span class="number">2</span>; <span class="comment">// 做一些处理并返回结果</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用DLL函数，并传递委托</span></span><br><span class="line"><span class="built_in">int</span> result = SomeFunction(myCallback);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Result from DLL: <span class="subst">&#123;result&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样，C#中的委托将在DLL内部的函数中被调用，并且C#代码可以处理回调函数的结果。</p>
<h2 id="调用-Win32-API"><a class="header-anchor" href="#调用-Win32-API">#</a>调用 Win32 API</h2>
<p>微软推出了 <a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Microsoft.Windows.CsWin32/">Microsoft.Windows.CsWin32</a> 包，使得调用 Win32 API 异常简单。<br>
安装包后，在工程目录下新建一个<code>NativeMethods.txt</code>文件，在其中写入要用到的符号，包括函数、常量等名称即可，每行一个。<br>
然后以<code>PInvoke.XXX</code>方式使用即可。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">#</a>参考</h2>
<p><a target="_blank" rel="noopener" href="https://www.mono-project.com/docs/advanced/pinvoke/">https://www.mono-project.com/docs/advanced/pinvoke/</a><br>
<a target="_blank" rel="noopener" href="https://manski.net/2012/05/pinvoke-tutorial-basics-part-1/">https://manski.net/2012/05/pinvoke-tutorial-basics-part-1/</a><br>
<a target="_blank" rel="noopener" href="https://manski.net/2012/06/pinvoke-tutorial-passing-strings-part-2/">https://manski.net/2012/06/pinvoke-tutorial-passing-strings-part-2/</a><br>
<a target="_blank" rel="noopener" href="https://manski.net/2012/06/pinvoke-tutorial-passing-parameters-part-3/">https://manski.net/2012/06/pinvoke-tutorial-passing-parameters-part-3/</a><br>
<a target="_blank" rel="noopener" href="https://manski.net/2012/06/pinvoke-tutorial-pinning-part-4/">https://manski.net/2012/06/pinvoke-tutorial-pinning-part-4/</a><br>
<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.unmanagedtype">UnmanagedType 枚举</a></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/10/15/unitycontainer/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/10/21/switch-atmosphere/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">数字类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E5%AF%B9%E7%85%A7%E8%A1%A8"><span class="toc-text">数字类型对照表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-text">布尔类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">传出字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">返回字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">结构类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84"><span class="toc-text">返回结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88"><span class="toc-text">返回结构指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-Win32-API"><span class="toc-text">调用 Win32 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/ashe27">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        


        

      </div>
    </div>
  </body>
</html>
